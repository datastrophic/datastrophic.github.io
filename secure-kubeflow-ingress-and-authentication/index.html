<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta property="og:site_name" content="datastrophic">
<meta property="og:type" content="article">
<meta property="og:image" content="https://datastrophic.io//img/datastrophic-strip-1.png">
<meta property="twitter:image" content="https://datastrophic.io//img/datastrophic-strip-1.png">
<meta name=title content="Secure Kubeflow Ingress and Authentication with Istio External Auth, Dex, and OAuth2 Proxy">
<meta property="og:title" content="Secure Kubeflow Ingress and Authentication with Istio External Auth, Dex, and OAuth2 Proxy">
<meta property="twitter:title" content="Secure Kubeflow Ingress and Authentication with Istio External Auth, Dex, and OAuth2 Proxy">
<meta name=description content="A blog about distributed systems, data platforms, and AI infrastructure">
<meta property="og:description" content="A blog about distributed systems, data platforms, and AI infrastructure">
<meta property="twitter:description" content="A blog about distributed systems, data platforms, and AI infrastructure">
<meta property="twitter:card" content="summary">
<meta name=keyword content="Spark, Mesos, Kubernetes, Kubeflow, Istio, SMACK stack, Cassandra, Kafka">
<link rel="shortcut icon" href=/img/favicon.ico>
<title>Secure Kubeflow Ingress and Authentication with Istio External Auth, Dex, and OAuth2 Proxy</title>
<link rel=canonical href=/secure-kubeflow-ingress-and-authentication/>
<link rel=stylesheet href=/css/bootstrap.min.css>
<link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css>
<link rel=stylesheet href=/css/zanshang.css>
<link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css rel=stylesheet type=text/css>
<link rel=stylesheet href=https://datastrophic.io/css/footer.css><link rel=stylesheet href=https://datastrophic.io/css/pager.css><link rel=stylesheet href=https://datastrophic.io/css/overrides.css>
<script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
</head>
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
<div class=container-fluid>
<div class="navbar-header page-scroll">
<button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
</div>
<div id=huxblog_navbar>
<div class=navbar-collapse>
<ul class="nav navbar-nav navbar-right">
<li>
<a href=/>Home</a>
</li>
<li><a href=/top/archive/>ARCHIVE</a></li>
<li><a href=/top/about/>ABOUT</a></li>
</ul>
</div>
</div>
</div>
</nav>
<script>var $body=document.body,$toggle=document.querySelector('.navbar-toggle'),$navbar=document.querySelector('#huxblog_navbar'),$collapse=document.querySelector('.navbar-collapse');$toggle.addEventListener('click',handleMagic);function handleMagic(a){$navbar.className.indexOf('in')>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf('in')<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script>
<style type=text/css>header.intro-header{background-image:url(/img/datastrophic-strip-1.png);color:#3a4145}</style>
<header class=intro-header style=background-image:url(/img/datastrophic-strip-1.png)>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<div class=post-heading>
<div class=tags>
<a class=tag href=/tags/kubernetes title=kubernetes>
kubernetes
</a>
<a class=tag href=/tags/istio title=istio>
istio
</a>
<a class=tag href=/tags/kubeflow title=kubeflow>
kubeflow
</a>
</div>
<h1>Secure Kubeflow Ingress and Authentication with Istio External Auth, Dex, and OAuth2 Proxy</h1>
<span class=meta>
Posted on
December 16, 2021
</span>
</div>
</div>
</div>
</div>
</header>
<article>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container">
<p>Publicly exposed insecure service endpoints on Kubernetes produce a major risk of malicious workloads being deployed on your clusters. We&rsquo;ve seen reports of the <a href=https://azure.microsoft.com/en-us/blog/detect-largescale-cryptocurrency-mining-attack-against-kubernetes-clusters/>Kubernetes Dashboard</a>, the <a href=https://www.microsoft.com/security/blog/2020/06/10/misconfigured-kubeflow-workloads-are-a-security-risk/>Kubeflow Central Dashboard</a>, and the <a href=https://techcommunity.microsoft.com/t5/microsoft-defender-for-cloud/new-large-scale-campaign-targets-kubeflow/ba-p/2425750>Kubeflow Pipelines</a> all were compromised when publicly exposed to the Internet. Combined with wide RBAC permissions, a publicly exposed software with workload scheduling capabilities opens your clusters for malicious deployments to anybody knowing the endpoint URL.</p>
<p>This blog post focuses on building a secure ingress and authentication stack on Kubernetes with Istio targeting Kubeflow installations. The post covers the existing approach used in the open-source Kubeflow distribution and its shortcomings and provides an alternative solution that uses the latest security features from Istio and an alternative authentication proxy.</p>
<h2 id=kubeflow-ingress-and-authentication>Kubeflow Ingress and Authentication</h2>
<h3 id=overview>Overview</h3>
<p>The main open source Kubeflow releases reside in the <a href=https://github.com/kubeflow/manifests>kubeflow/manifests</a> repository that aims at easing the installation and providing a tested starting point for derived distributions (<a href=https://github.com/kubeflow/manifests#installation>link</a>). The repository provides manifests for both the Kubeflow components and the dependencies required for the ingress and security stack such as Istio, Dex, and OIDC AuthService. Kubeflow relies on Istio for ingress, traffic routing, and authorization policies for multi-tenancy. Let&rsquo;s consider the high-level ingress architecture and resource placement shown in the diagram below:</p>
<p>
<img src=/blog/2021-12-16/kubeflow-default-ingress.png alt="Default Kubeflow Ingress">
</p>
<p>Kubeflow installation configures the default shared Istio Ingress GatewayÂ running in the <code>istio-system</code> namespace using <code>Gateway</code> and <code>VirtualService</code> custom resources for routing and the <code>EnvoyFilter</code> for the request authorization. The <code>EnvoyFilter</code> forwards the incoming traffic to the <a href=https://github.com/arrikto/oidc-authservice>OIDC AuthService</a> that validates the authorization cookie and can either allow the request to proceed, deny it due to invalid authorization, or trigger an authentication workflow with an external system such as <a href=https://dexidp.io/>Dex</a>.</p>
<h3 id=shortcomings-of-the-existing-approach>Shortcomings of the existing approach</h3>
<h4 id=tight-coupling-of-the-ingress-stack-with-kubeflow>Tight coupling of the ingress stack with Kubeflow</h4>
<p>Kubeflow relies on several external systems for its security-related features: cert-manager, Istio, Dex, and OIDC AuthService. The convenience of <a href=https://github.com/kubeflow/manifests>kubeflow/manifests</a> providing all of these dependencies in one place brings additional coupling when the ingress resources are deployed. For example, <code>Gateway</code> and <code>EnvoyFilter</code> resources are deployed in the <code>kubeflow</code> namespace but at the same time, they configure the default Istio Ingress Gateway running in the <code>istio-system</code> namespace that can be used by other services in the cluster. When the <code>Gateway</code> is uninstalled, the configuration for the shared ingress gateway is dropped with it too.</p>
<p>When Kubeflow installation becomes yet another cluster citizen, it should be able to seamlessly integrate with the existing platform-side components without producing alternative authentication paths or overwriting existing routes in the default Istio Gateway.</p>
<h4 id=use-of-the-insecure-gateway-and-endpoints>Use of the insecure Gateway and endpoints</h4>
<p>As of version 1.4, the Kubeflow manifests use HTTP Gateway without any TLS in place. TLS is an essential security measure nowadays and, surprisingly, publicly exposed endpoints serve plaintext HTTP disregarding the environment they are deployed into (e.g. on-premise or air-gapped clusters).</p>
<p>The Dex installation coming with Kubeflow is also exposed via the same <code>Gateway</code> and its clients (such as OIDC AuthService) don&rsquo;t have a way to verify the identity of the service. Although the OIDC AuthService supports the functionality for verifying the OIDC provider endpoint by providing a CA bundle it is not utilized.</p>
<h4 id=envoyfilter-maintainability-issue>EnvoyFilter maintainability issue</h4>
<p>Envoy&rsquo;s <code>ext_authz</code> filter configured with the <code>EnvoyFilter</code> CRD used for forwarding requests to the OIDC AuthService is a pretty low-level primitive which could be difficult to maintain and troubleshoot. The major pain points are described in the Istio <a href="https://docs.google.com/document/d/1V4mCQCw7mlGp0zSQQXYoBdbKMDnkPOjeyUb85U07iSI/edit#heading=h.kin6s6rv2n0i">Better External Authorization</a> design doc. Here are a few excerpts that are relevant for Kubeflow:</p>
<ul>
<li>No support for the conditional triggering of the external authorization flow. Some paths don&rsquo;t need it (e.g. user-facing authentication endpoint itself).</li>
<li>As <code>ext_authz</code> depends on the Envoy API, the <code>EnvoyFilter</code> can start failing after a small change in the upstream. Sometimes they are <strong>failing silently</strong>.</li>
<li>Overall difficult maintenance and troubleshooting of the <code>EnvoyFilter</code> CRD.</li>
</ul>
<h4 id=oidc-authservice-maintenance-and-community-support>OIDC AuthService maintenance and community support</h4>
<p>OIDC AuthService is a great solution for the auth proxy, however, the <a href=https://github.com/arrikto/oidc-authservice/graphs/commit-activity>project&rsquo;s GitHub</a> doesn&rsquo;t look very active and it is not clear what amount of maintenance it receives. It also doesn&rsquo;t have any releases in its GitHub repository so the whole release process is opaque. The single source of truth seems to be the Docker image tag (commit hash) used in manifests.
Another concern with OIDC AuthService is that it seems to be tailored for Kubeflow needs only and is not used in any other setup. This could make it potentially vulnerable for non-Kubeflow specific use-cases that haven&rsquo;t been tested but might happen in production deployments.</p>
<h2 id=proposed-solution-for-secure-ingress-and-external-authentication>Proposed solution for Secure Ingress and External Authentication</h2>
<h3 id=overview-1>Overview</h3>
<h4 id=decoupling-the-ingress-stack-from-kubeflow>Decoupling the ingress stack from Kubeflow</h4>
<p>The ingress and authentication stack should be treated as a cluster-scoped entity so that all cluster tenants (services and applications) can integrate with it and benefit from the pre-configured security and authentication flow. That way, Kubeflow becomes another consumer of the authentication stack and doesn&rsquo;t deal with the installation of the security primitives.</p>
<p>Independent installation and management of the ingress and authentication stack allows using the latest stable software versions and the recommended installation methods such as official Helm Charts instead of the back-ported manifests</p>
<h4 id=securing-the-endpoints>Securing the Endpoints</h4>
<p>Istio natively supports TLS at the <code>Gateway</code> and with the Cert-manager available on the cluster, it is possible to create a CA <code>ClusterIssuer</code> and provide a certificate to the <code>Gateway</code>. The CA <code>ClusterIssuer</code> can then also be used to mount a CA file to the authentication proxy for validating the Dex identity. Additionally, it is beneficial to enable mutual TLS for all user-facing and authentication-related components when possible (not all Kubeflow components work well when Istio sidecars are injected).</p>
<h4 id=using-istio-external-auth>Using Istio External Auth</h4>
<p>Starting from version 1.9 Istio supports <a href=https://istio.io/latest/docs/tasks/security/authorization/authz-custom/>external authorization</a> and allows configuring <code>AuthorizationPolicies</code> to delegate authorization to external systems. This functionality came to replace the low-level <code>EnvoyFilter</code> configuration API and was driven by the shortcomings of the <code>ext_authz</code> approach. There&rsquo;s a great blog post from Istio describing it: <a href=https://istio.io/latest/blog/2021/better-external-authz/>Better External Authorization</a>.</p>
<h4 id=migrating-to-oauth2-proxy-with-dex>Migrating to OAuth2 Proxy with Dex</h4>
<p>Dex is a popular choice for Kubernetes authentication used in production, however, an alternative solution will be used instead of OIDC AuthService. <a href=https://oauth2-proxy.github.io/oauth2-proxy/>OAuth2 Proxy</a> looks like a better alternative based on its functionality, <a href=https://github.com/oauth2-proxy/oauth2-proxy/graphs/commit-activity>GitHub activity</a>, availability of the versioned releases, quality <a href=https://oauth2-proxy.github.io/oauth2-proxy/docs/configuration/overview>documentation</a>, and the official Helm Chart for the installation.</p>
<h3 id=deployment-layout>Deployment layout</h3>
<p>Let&rsquo;s consider the following deployment and ingress diagram for a dedicated Kubeflow cluster:</p>
<p>
<img src=/blog/2021-12-16/kubeflow-target-ingress.png alt="Kubeflow Target Ingress">
</p>
<p>There are several differences and improvements compared to the default Kubeflow installation:</p>
<ul>
<li>The proposed layout follows the idea of the centralized security and authentication stack independent from Kubeflow. The consumers of the stack can be added to or removed from a cluster without affecting other consumers. This setup is beneficial for installations where Kubeflow is yet another tenant sharing the cluster with other business applications.</li>
<li>The Secure Istio Gateway with TLS termination running in a dedicated ingress namespace as <a href=https://istio.io/latest/docs/setup/additional-setup/gateway/#deploying-a-gateway>the security best practice doesn&rsquo;t recommend installing it in the Istio namespace</a> and uses a <code>Certificate</code> issued by the cert-manager.</li>
<li>Istio External Authorization is configured for the Ingress Gateway by an <code>AuthorizationPolicy</code> and verifies the incoming requests with Dex via OAuth2 Proxy. Dex and OAuth2 Proxy have <code>VirtualService</code> routes defined for them and will be using the Ingress Gateway address for the authentication endpoints and callbacks so that both internal and external users and systems have the access to them. This setup is useful when the OIDC provider is external to the cluster or running at a different address.</li>
<li>Security-related components deployed in a dedicated namespace and can have additional policies applied to them in a narrow scope. This layout is also beneficial if other services running on the cluster and which require authentication but are not related to Kubeflow, for example, user-facing Grafana and Prometheus.</li>
</ul>
<h2 id=implementing-secure-ingress-and-authentication>Implementing Secure Ingress and Authentication</h2>
<p>This section contains practical steps and code snippets for installing and configuring the secure ingress and authentication stack. It mostly focuses on the generic part that applies to any cluster that requires setting up the security, and at the end provides a sub-section with a basic Kubeflow installation to verify the setup.</p>
<p>The main topics covered in this section include setting up required security dependencies with Helm, creating a CA <code>ClusterIssuer</code> with a self-signed CA, configuring secure ingress, configuring Istio External Authorization, installing and configuring OAuth2 Proxy and Dex for authentication, and installing a minimalistic Kubeflow distribution.</p>
<blockquote>
<p><strong>NOTE:</strong> The following tutorial was created on an on-premises deployment with MetalLB assigning addresses for <code>Services</code> with the <code>LoadBalancer</code> type. The exposed ingress endpoints with the network IPs assigned will be referenced by the IP address instead of FQDN for simplicity and to avoid setting up and configuring a DNS Server.</p>
</blockquote>
<h3 id=securing-the-ingress-gateway>Securing the Ingress Gateway</h3>
<p>The first step in configuring secure ingress on a cluster is to get the required software and configure it to serve the traffic. Disregarding whether it is required solely for Kubeflow or generic cluster security, this part of the setup will be the same.</p>
<h4 id=installing-cert-manager-istio-and-ingress-gateway>Installing Cert-manager, Istio, and Ingress Gateway</h4>
<p>Installing cert-manager:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>helm repo add jetstack https://charts.jetstack.io
helm repo update  

helm install cert-manager jetstack/cert-manager <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --version v1.6.1 <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --set <span style=color:#8be9fd;font-style:italic>installCRDs</span><span style=color:#ff79c6>=</span><span style=color:#8be9fd;font-style:italic>true</span> <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --namespace cert-manager <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --create-namespace
</code></pre></div><p>Istio ships independent Helm Charts for CRDs, Istiod, and the Ingress Gateway. The source code for the Charts can be found <a href=https://github.com/istio/istio/tree/master/manifests/charts>here</a>. At this point, only CRDs and Istiod will be needed:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>helm repo add istio https://istio-release.storage.googleapis.com/charts
helm repo update  

helm install istio-base istio/base <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --version 1.12.1 <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --namespace istio-system <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --create-namespace  

helm install istiod istio/istiod <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --version 1.12.1 <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --namespace istio-system <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --wait
</code></pre></div><p>Create the Istio Ingress Gateway in a dedicated <code>ingress</code> namespace:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>helm install istio-ingressgateway istio/gateway <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --version 1.12.1 <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --namespace ingress <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --create-namespace
  --wait
</code></pre></div><p>The Ingress Gateway from this Chart creates an Envoy Proxy <code>Deployment</code> and a <code>Service</code> with the <code>LoadBalancer</code> type. At this point there are no routes defined and all requests to the <code>Service</code> will be dropped (you can check it with <code>curl</code>). Verify the <code>Service</code> has the external address assigned. For example:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc istio-ingressgateway -n ingress

NAME                   TYPE           CLUSTER-IP      EXTERNAL-IP      PORT<span style=color:#ff79c6>(</span>S<span style=color:#ff79c6>)</span>                                      AGE
istio-ingressgateway   LoadBalancer   10.99.197.129   192.168.50.150   15021:31107/TCP,80:32027/TCP,443:31920/TCP   11m
</code></pre></div><h4 id=creating-ca-clusterissuer-for-signing-certificates>Creating CA <code>ClusterIssuer</code> for signing certificates</h4>
<p>For simplicity, we will be using the <code>ClusterIssuer</code> to ease the certificate issuance and use the same CA for signing all certificates. For that, it is required to create a CA key and certificate to provide to the Cert-manager <code>ClusterIssuer</code>. We will use <a href=https://github.com/cloudflare/cfssl>cfssl</a> but any other appropriate<br>
tool can be used instead.</p>
<p>Create a CSR (Certificate Signing Request) file in json format. For example:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#f1fa8c>&lt;&lt;EOF &gt; csr.json  
</span><span style=color:#f1fa8c>{  
</span><span style=color:#f1fa8c>  &#34;CN&#34;: &#34;Datastrophic&#34;,
</span><span style=color:#f1fa8c>  &#34;key&#34;: {
</span><span style=color:#f1fa8c>    &#34;algo&#34;: &#34;rsa&#34;,
</span><span style=color:#f1fa8c>	&#34;size&#34;: 2048
</span><span style=color:#f1fa8c>  },
</span><span style=color:#f1fa8c>  &#34;names&#34;: [
</span><span style=color:#f1fa8c>    {
</span><span style=color:#f1fa8c>	  &#34;C&#34;: &#34;US&#34;,
</span><span style=color:#f1fa8c>	  &#34;L&#34;:
</span><span style=color:#f1fa8c>	  &#34;San Francisco&#34;,
</span><span style=color:#f1fa8c>	  &#34;O&#34;: &#34;Datastrophic&#34;,
</span><span style=color:#f1fa8c>	  &#34;ST&#34;: &#34;California&#34;
</span><span style=color:#f1fa8c>	}
</span><span style=color:#f1fa8c>  ]
</span><span style=color:#f1fa8c>}
</span><span style=color:#f1fa8c>EOF</span>
</code></pre></div><p>Then, run <code>cfssl</code> to generate the initial CA key and certificate:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cfssl gencert -initca csr.json | cfssljson -bare ca
</code></pre></div><p>Create a Kubernetes Secret to hold the key and certificate, as per <a href=https://cert-manager.io/docs/configuration/ca/#deployment>cert-manager docs</a>. The secret for the <code>ClusterIssuer</code> should be created in the <a href=https://cert-manager.io/docs/configuration/ca/#deployment>&ldquo;cluster resource namespace&rdquo;</a> which defaults to <code>cert-manager</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret tls ca-secret <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --namespace cert-manager <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --cert<span style=color:#ff79c6>=</span>ca.pem <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --key<span style=color:#ff79c6>=</span>ca-key.pem
</code></pre></div><p>Create a CA <code>ClusterIssuer</code> referencing the previously created <code>Secret</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f - <span style=color:#f1fa8c>&lt;&lt;EOF
</span><span style=color:#f1fa8c>apiVersion: cert-manager.io/v1  
</span><span style=color:#f1fa8c>kind: ClusterIssuer  
</span><span style=color:#f1fa8c>metadata:  
</span><span style=color:#f1fa8c>  name: ca-issuer
</span><span style=color:#f1fa8c>spec:  
</span><span style=color:#f1fa8c>  ca:
</span><span style=color:#f1fa8c>    secretName: ca-secret
</span><span style=color:#f1fa8c>EOF</span>
</code></pre></div><p>Verify the <code>ClusterIssuer</code> is ready:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get clusterissuer -o wide

NAME      READY   STATUS                AGE
ca-issuer True    Signing CA verified   2s
</code></pre></div><p>More <code>ClusterIssuer</code> configuration options available in the <a href=https://cert-manager.io/docs/configuration/>Cert-manager docs</a>.</p>
<h4 id=configuring-istio-gateway-to-serve-https-traffic>Configuring Istio Gateway to serve HTTPS traffic</h4>
<p>To expose services via HTTPS, it is required to configure a secure Istio Gateway. For this purpose, we will use Cert-manager to issue a certificate for the Istio Ingress Gateway address and provide it to the <code>Gateway</code>.</p>
<p>Discover the <code>IngressGateway</code> address to use in the certificate:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#8be9fd;font-style:italic>export</span> <span style=color:#8be9fd;font-style:italic>INGRESS_HOST</span><span style=color:#ff79c6>=</span><span style=color:#ff79c6>$(</span>kubectl get svc istio-ingressgateway --namespace ingress -o yaml -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;{.status.loadBalancer.ingress[0].ip}&#39;</span><span style=color:#ff79c6>)</span>
</code></pre></div><blockquote>
<p><strong>NOTE:</strong> if running in the cloud and the <code>LoadBalancer</code> service type is bound to a load balancer, then <code>.status.loadBalancer.ingress[0].ip</code> might render an empty result. If a <code>LoadBalancer</code> service has a DNS name assigned to it, use <code>.status.loadBalancer.ingress[0].hostname</code> instead. Alternatively, run <code>kubectl describe svc istio-ingressgateway --namespace ingress</code> and save the publicly exposed address.</p>
</blockquote>
<p>The <code>Certificate</code> would look as follows (we&rsquo;ll be using the IP address from the previous step in the <code>ipAddresses</code> field):</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f - <span style=color:#f1fa8c>&lt;&lt;EOF
</span><span style=color:#f1fa8c>apiVersion: cert-manager.io/v1
</span><span style=color:#f1fa8c>kind: Certificate
</span><span style=color:#f1fa8c>metadata:
</span><span style=color:#f1fa8c>  name: gateway-cert
</span><span style=color:#f1fa8c>  namespace: ingress
</span><span style=color:#f1fa8c>spec:
</span><span style=color:#f1fa8c>  secretName: gateway-cert
</span><span style=color:#f1fa8c>  ipAddresses:
</span><span style=color:#f1fa8c>  - &#34;${INGRESS_HOST}&#34;
</span><span style=color:#f1fa8c>  duration: 2160h # 90d
</span><span style=color:#f1fa8c>  renewBefore: 360h # 15d
</span><span style=color:#f1fa8c>  subject:
</span><span style=color:#f1fa8c>    organizations:
</span><span style=color:#f1fa8c>      - Datastrophic
</span><span style=color:#f1fa8c>  issuerRef:
</span><span style=color:#f1fa8c>    name: ca-issuer
</span><span style=color:#f1fa8c>    kind: ClusterIssuer
</span><span style=color:#f1fa8c>EOF</span>
</code></pre></div><p>Verify the <code>Certificate</code> is created:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get certificate gateway-cert -o wide -n ingress  

NAME           READY   SECRET         ISSUER      STATUS                                          AGE
gateway-cert   True    gateway-cert   ca-issuer   Certificate is up to date and has not expired   16s
</code></pre></div><p>Create a secure Istio <code>Gateway</code> that configures the Ingress proxies to use the certificate created at the previous step:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f - <span style=color:#f1fa8c>&lt;&lt;EOF
</span><span style=color:#f1fa8c>apiVersion: networking.istio.io/v1beta1
</span><span style=color:#f1fa8c>kind: Gateway
</span><span style=color:#f1fa8c>metadata:
</span><span style=color:#f1fa8c>  name: ingress-gateway
</span><span style=color:#f1fa8c>  namespace: ingress
</span><span style=color:#f1fa8c>spec:
</span><span style=color:#f1fa8c>  selector:
</span><span style=color:#f1fa8c>    app: istio-ingressgateway
</span><span style=color:#f1fa8c>	istio: ingressgateway
</span><span style=color:#f1fa8c>  servers:
</span><span style=color:#f1fa8c>  - port:
</span><span style=color:#f1fa8c>      number: 443
</span><span style=color:#f1fa8c>      name: https-main
</span><span style=color:#f1fa8c>      protocol: HTTPS
</span><span style=color:#f1fa8c>    hosts:
</span><span style=color:#f1fa8c>    - &#34;*&#34;
</span><span style=color:#f1fa8c>    tls:
</span><span style=color:#f1fa8c>      mode: SIMPLE
</span><span style=color:#f1fa8c>      credentialName: gateway-cert
</span><span style=color:#f1fa8c>EOF</span>
</code></pre></div><p>Before deploying the <code>Gateway</code>, <code>curl</code> to <code>https://$INGRESS_HOST</code> returns <code>Connection refused</code>. However, after the <code>Gateway</code> was created, the certificate can be verified by running:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl --cacert ca.pem -v https://<span style=color:#8be9fd;font-style:italic>$INGRESS_HOST</span>
</code></pre></div><p>Where <code>--cacert ca.pem</code> points to the previously created root CA. It is expected that the above command returns <code>404</code> as there are no <code>VirtualService</code> routes configured yet.</p>
<h3 id=authorizing-user-requests>Authorizing user requests</h3>
<p>After the TLS ingress is configured, we can now proceed with Istio External Authorization, Dex, and OAuth2 Proxy. As a result, the Istio Ingress Gateway will be using OAuth2 Proxy as an external authorization service which in turn will trigger authorization flow with Dex. Dex configuration for this blog post will serve static users but can be configured to work with supported providers.</p>
<p>First, let&rsquo;s create a dedicated <code>auth</code>namespace with Istio sidecar injection enabled:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f - <span style=color:#f1fa8c>&lt;&lt;EOF
</span><span style=color:#f1fa8c>apiVersion: v1
</span><span style=color:#f1fa8c>kind: Namespace
</span><span style=color:#f1fa8c>metadata:
</span><span style=color:#f1fa8c>  name: auth
</span><span style=color:#f1fa8c>  labels:
</span><span style=color:#f1fa8c>    istio-injection: enabled
</span><span style=color:#f1fa8c>EOF</span>
</code></pre></div><h4 id=installing-dex-and-configuring-clients>Installing Dex and configuring clients</h4>
<p>Dex will be installed using Helm, and an example Dex configuration can be found <a href=https://github.com/dexidp/dex/blob/master/config.yaml.dist>here</a>. In the configuration below, the Dex configuration contains a record for an OAuth2 Proxy static client that at this point is not yet installed. It also includes two static users for testing:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#6272a4># bcrypt hash for &#34;password&#34;</span>
<span style=color:#8be9fd;font-style:italic>export</span> <span style=color:#8be9fd;font-style:italic>PWD_HASH</span><span style=color:#ff79c6>=</span><span style=color:#ff79c6>$(</span>htpasswd -bnBC <span style=color:#bd93f9>10</span> <span style=color:#f1fa8c>&#34;&#34;</span> password | tr -d <span style=color:#f1fa8c>&#39;:\n&#39;</span><span style=color:#ff79c6>)</span>

cat <span style=color:#f1fa8c>&lt;&lt;EOF &gt; dex-values.yaml
</span><span style=color:#f1fa8c>config:
</span><span style=color:#f1fa8c>  issuer: &#34;https://${INGRESS_HOST}/dex&#34;
</span><span style=color:#f1fa8c>
</span><span style=color:#f1fa8c>  storage:
</span><span style=color:#f1fa8c>    type: kubernetes
</span><span style=color:#f1fa8c>    config:
</span><span style=color:#f1fa8c>      inCluster: true
</span><span style=color:#f1fa8c>
</span><span style=color:#f1fa8c>  oauth2:
</span><span style=color:#f1fa8c>    skipApprovalScreen: true
</span><span style=color:#f1fa8c>
</span><span style=color:#f1fa8c>  staticClients:
</span><span style=color:#f1fa8c>  - id: oauth2-proxy
</span><span style=color:#f1fa8c>    name: OAuth2 Proxy
</span><span style=color:#f1fa8c>    secret: &#34;LG7jUjNiyVDPJdlarO5Mgz3CxS7kNL/1OZ0spRsL&#34;
</span><span style=color:#f1fa8c>    redirectURIs:
</span><span style=color:#f1fa8c>      - &#34;https://${INGRESS_HOST}/oauth2/callback&#34;
</span><span style=color:#f1fa8c>
</span><span style=color:#f1fa8c>  # Password DB must be enabled in order to specify static users
</span><span style=color:#f1fa8c>  enablePasswordDB: true
</span><span style=color:#f1fa8c>  staticPasswords:
</span><span style=color:#f1fa8c>  - email: &#34;user1@datastrophic.io&#34;
</span><span style=color:#f1fa8c>    hash: &#34;${PWD_HASH}&#34;
</span><span style=color:#f1fa8c>  - email: &#34;user2@datastrophic.io&#34;
</span><span style=color:#f1fa8c>    hash: &#34;${PWD_HASH}&#34;
</span><span style=color:#f1fa8c>EOF</span>
</code></pre></div><p>Install Dex with the provided configuration:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>helm repo add dex https://charts.dexidp.io
helm repo update

helm install dex dex/dex <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --version 0.6.3 <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --values dex-values.yaml <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --namespace auth <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --wait
</code></pre></div><p>Expose Dex at the endpoint&rsquo;s <code>/dex</code> path via a <code>VirtualService</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f - <span style=color:#f1fa8c>&lt;&lt;EOF
</span><span style=color:#f1fa8c>apiVersion: networking.istio.io/v1beta1
</span><span style=color:#f1fa8c>kind: VirtualService
</span><span style=color:#f1fa8c>metadata:
</span><span style=color:#f1fa8c> name: dex
</span><span style=color:#f1fa8c> namespace: auth
</span><span style=color:#f1fa8c>spec:
</span><span style=color:#f1fa8c> hosts:
</span><span style=color:#f1fa8c> - &#34;*&#34;
</span><span style=color:#f1fa8c> gateways:
</span><span style=color:#f1fa8c> - ingress/ingress-gateway
</span><span style=color:#f1fa8c> http:
</span><span style=color:#f1fa8c> - name: &#34;dex&#34;
</span><span style=color:#f1fa8c>   match:
</span><span style=color:#f1fa8c>   - uri:
</span><span style=color:#f1fa8c>       prefix: &#34;/dex&#34;
</span><span style=color:#f1fa8c>   route:
</span><span style=color:#f1fa8c>   - destination:
</span><span style=color:#f1fa8c>       host: dex.auth.svc.cluster.local
</span><span style=color:#f1fa8c>       port:
</span><span style=color:#f1fa8c>         number: 5556
</span><span style=color:#f1fa8c>EOF</span>
</code></pre></div><h4 id=installing-oauth2-proxy>Installing OAuth2 Proxy</h4>
<p>OAuth2 Proxy has quite a few configuration options described in <a href=https://oauth2-proxy.github.io/oauth2-proxy/docs/configuration/oauth_provider#openid-connect-provider>oauth2-proxy documentation</a><br>
and available in the example <a href=https://github.com/oauth2-proxy/oauth2-proxy/blob/master/contrib/local-environment/kubernetes/values.yaml>values.yaml</a> in GitHub. The majority of the examples set <code>ssl_insecure_skip_verify</code> parameter to <code>true</code> to skip the verification of the OIDC provider endpoint. This is convenient when it is running with a self-signed certificate, however, if the certificate verification is skipped, this means we&rsquo;re ignoring who is authenticating the users. In this setup, a dedicated certificate will be issued for the ingress endpoint running Dex and mounted to the OAuth2 Proxy for validating the certificates against the CA.</p>
<p>Create a second certificate for the Gateway address but in the <code>auth</code> namespace:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f - <span style=color:#f1fa8c>&lt;&lt;EOF
</span><span style=color:#f1fa8c>apiVersion: cert-manager.io/v1
</span><span style=color:#f1fa8c>kind: Certificate
</span><span style=color:#f1fa8c>metadata:
</span><span style=color:#f1fa8c>  name: gateway-cert
</span><span style=color:#f1fa8c>  namespace: auth
</span><span style=color:#f1fa8c>spec:
</span><span style=color:#f1fa8c>  secretName: gateway-cert
</span><span style=color:#f1fa8c>  ipAddresses:
</span><span style=color:#f1fa8c>  - &#34;${INGRESS_HOST}&#34;
</span><span style=color:#f1fa8c>  duration: 2160h # 90d
</span><span style=color:#f1fa8c>  renewBefore: 360h # 15d
</span><span style=color:#f1fa8c>  subject:
</span><span style=color:#f1fa8c>    organizations:
</span><span style=color:#f1fa8c>      - Datastrophic
</span><span style=color:#f1fa8c>  issuerRef:
</span><span style=color:#f1fa8c>    name: ca-issuer
</span><span style=color:#f1fa8c>    kind: ClusterIssuer
</span><span style=color:#f1fa8c>EOF</span>
</code></pre></div><p>Create the OAuth2 Proxy Helm configuration:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#f1fa8c>&lt;&lt;EOF &gt; oauth2-proxy-values.yaml
</span><span style=color:#f1fa8c>config:
</span><span style=color:#f1fa8c>  clientID: &#34;oauth2-proxy&#34;
</span><span style=color:#f1fa8c>  # openssl rand -base64 32 | head -c 40
</span><span style=color:#f1fa8c>  clientSecret: &#34;LG7jUjNiyVDPJdlarO5Mgz3CxS7kNL/1OZ0spRsL&#34;
</span><span style=color:#f1fa8c>  # openssl rand -base64 32 | head -c 32 | base64
</span><span style=color:#f1fa8c>  #cookieSecret: &#34;SXRNTGYzNUFtNi9MTGUvbXJmUnlLdUlYTU00a29ick4=&#34;
</span><span style=color:#f1fa8c>  configFile: |-
</span><span style=color:#f1fa8c>    provider = &#34;oidc&#34;
</span><span style=color:#f1fa8c>    provider_ca_files = &#34;/etc/gateway-cert/ca.crt&#34;
</span><span style=color:#f1fa8c>    oidc_issuer_url = &#34;https://${INGRESS_HOST}/dex&#34;
</span><span style=color:#f1fa8c>
</span><span style=color:#f1fa8c>    set_authorization_header = true
</span><span style=color:#f1fa8c>    set_xauthrequest = true
</span><span style=color:#f1fa8c>    cookie_samesite = &#34;lax&#34;
</span><span style=color:#f1fa8c>
</span><span style=color:#f1fa8c>    email_domains = [&#34;*&#34;]
</span><span style=color:#f1fa8c>    skip_provider_button = true
</span><span style=color:#f1fa8c>    upstreams = [ &#34;static://200&#34; ]
</span><span style=color:#f1fa8c>
</span><span style=color:#f1fa8c>extraVolumes:
</span><span style=color:#f1fa8c>  - name: gateway-cert
</span><span style=color:#f1fa8c>    secret:
</span><span style=color:#f1fa8c>      secretName: gateway-cert
</span><span style=color:#f1fa8c>
</span><span style=color:#f1fa8c>extraVolumeMounts:
</span><span style=color:#f1fa8c>  - mountPath: /etc/gateway-cert/
</span><span style=color:#f1fa8c>    name: gateway-cert
</span><span style=color:#f1fa8c>EOF</span>
</code></pre></div><p>Install OAuth2 Proxy with the provided configuration:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>helm repo add oauth2-proxy https://oauth2-proxy.github.io/manifests
helm repo update

helm install oauth2-proxy oauth2-proxy/oauth2-proxy <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --version 5.0.6 <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --namespace auth <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --values oauth2-proxy-values.yaml <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --wait
</code></pre></div><p>Expose OAuth2 Proxy at the endpoint&rsquo;s <code>/oauth2</code> path via a <code>VirtualService</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f - <span style=color:#f1fa8c>&lt;&lt;EOF
</span><span style=color:#f1fa8c>apiVersion: networking.istio.io/v1beta1
</span><span style=color:#f1fa8c>kind: VirtualService
</span><span style=color:#f1fa8c>metadata:
</span><span style=color:#f1fa8c> name: oauth2-proxy
</span><span style=color:#f1fa8c> namespace: auth
</span><span style=color:#f1fa8c>spec:
</span><span style=color:#f1fa8c> hosts:
</span><span style=color:#f1fa8c> - &#34;*&#34;
</span><span style=color:#f1fa8c> gateways:
</span><span style=color:#f1fa8c> - ingress/ingress-gateway
</span><span style=color:#f1fa8c> http:
</span><span style=color:#f1fa8c> - name: &#34;oauth2&#34;
</span><span style=color:#f1fa8c>   match:
</span><span style=color:#f1fa8c>   - uri:
</span><span style=color:#f1fa8c>       prefix: &#34;/oauth2&#34;
</span><span style=color:#f1fa8c>   route:
</span><span style=color:#f1fa8c>   - destination:
</span><span style=color:#f1fa8c>       host: oauth2-proxy.auth.svc.cluster.local
</span><span style=color:#f1fa8c>       port:
</span><span style=color:#f1fa8c>         number: 5556
</span><span style=color:#f1fa8c>EOF</span>
</code></pre></div><h4 id=configuring-istio-external-authorization>Configuring Istio External Authorization</h4>
<p>Istio External Authorization is a mesh-wide configuration property that is applied to Istiod. In the example below, we register a new external authorization service (OAuth2 Proxy):</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#f1fa8c>&lt;&lt;EOF &gt; istio-values.yaml
</span><span style=color:#f1fa8c>meshConfig:
</span><span style=color:#f1fa8c>  extensionProviders:
</span><span style=color:#f1fa8c>    - name: oauth2-proxy
</span><span style=color:#f1fa8c>      envoyExtAuthzHttp:
</span><span style=color:#f1fa8c>        service: oauth2-proxy.auth.svc.cluster.local
</span><span style=color:#f1fa8c>        port: 80
</span><span style=color:#f1fa8c>        includeHeadersInCheck: [&#34;authorization&#34;, &#34;cookie&#34;]
</span><span style=color:#f1fa8c>        headersToUpstreamOnAllow: [&#34;authorization&#34;, &#34;path&#34;, &#34;x-auth-request-user&#34;, &#34;x-auth-request-email&#34;, &#34;x-auth-request-access-token&#34;]
</span><span style=color:#f1fa8c>        headersToDownstreamOnDeny: [&#34;content-type&#34;, &#34;set-cookie&#34;]
</span><span style=color:#f1fa8c>EOF</span>

helm upgrade istiod istio/istiod <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --namespace istio-system <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --values istio-values.yaml <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --wait

kubectl rollout restart deployment/istiod -n istio-system
</code></pre></div><p>And to enable the external authorization, it is required to apply the <code>AuthorizationPolicy</code> referencing the above extension provider to the Istio Ingress Gateway:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f - <span style=color:#f1fa8c>&lt;&lt;EOF
</span><span style=color:#f1fa8c>apiVersion: security.istio.io/v1beta1
</span><span style=color:#f1fa8c>kind: AuthorizationPolicy
</span><span style=color:#f1fa8c>metadata:
</span><span style=color:#f1fa8c>  name: external-auth
</span><span style=color:#f1fa8c>  namespace: ingress
</span><span style=color:#f1fa8c>spec:
</span><span style=color:#f1fa8c>  selector:
</span><span style=color:#f1fa8c>    matchLabels:
</span><span style=color:#f1fa8c>      app: istio-ingressgateway
</span><span style=color:#f1fa8c>      istio: ingressgateway
</span><span style=color:#f1fa8c>  action: CUSTOM
</span><span style=color:#f1fa8c>  provider:
</span><span style=color:#f1fa8c>    name: oauth2-proxy
</span><span style=color:#f1fa8c>  rules:
</span><span style=color:#f1fa8c>    - to:
</span><span style=color:#f1fa8c>        - operation:
</span><span style=color:#f1fa8c>            hosts: [&#34;*&#34;]
</span><span style=color:#f1fa8c>            notPaths: [&#34;/dex/*&#34;]  # skipping Dex running on the same Gateway to avoid redirect loops
</span><span style=color:#f1fa8c>EOF</span>
</code></pre></div><p>Now, everything is ready and all unauthorized requests should be redirected to Dex by OAuth2 Proxy. To verify that, navigate to <a href=https://INGRESS_HOST><code>https://$INGRESS_HOST</code></a> in your browser. There are two static users <code>user1@datastrophic.io</code> and <code>user2@datastrophic.io</code> with a password: <code>password</code>. As we don&rsquo;t have user-facing applications running yet, you&rsquo;ll be redirected to the root path and get a <code>404</code> which is expected.</p>
<h3 id=base-kubeflow-installation>Base Kubeflow installation</h3>
<p>To verify the secure ingress for Kubeflow, let&rsquo;s install several basic components, log in as different users, and use the collaboration feature to share a notebook.</p>
<p><a href=https://github.com/datastrophic/kubeflow-kustomize>datastrophic/kubeflow-kustomize</a> repository contains kustomizations for a demo installation of the Kubeflow based on <a href=https://github.com/kubeflow/manifests>kubeflow/manifests</a> repository. The kustomizations in the repository modify base manifests to make them work with the custom Istio <code>Gateway</code> and OAuth2 Proxy headers. The kustomizations also patch the Central Dashboard <code>VirtualService</code> to add a redirect for <code>/logout</code> path to the OAuth2 Proxy sign out endpoint:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#ff79c6>apiVersion</span>: networking.istio.io/v1beta1
<span style=color:#ff79c6>kind</span>: VirtualService
<span style=color:#ff79c6>metadata</span>:
  <span style=color:#ff79c6>name</span>: centraldashboard
<span style=color:#ff79c6>spec</span>:
  <span style=color:#ff79c6>gateways</span>:
  - ingress/ingress-gateway
  <span style=color:#ff79c6>http</span>:
  - <span style=color:#ff79c6>match</span>:
    - <span style=color:#ff79c6>uri</span>:
        <span style=color:#ff79c6>exact</span>: /logout
    <span style=color:#ff79c6>name</span>: logout
    <span style=color:#ff79c6>redirect</span>:
      <span style=color:#ff79c6>uri</span>: /oauth2/sign_out
  - <span style=color:#ff79c6>match</span>:
    - <span style=color:#ff79c6>uri</span>:
        <span style=color:#ff79c6>prefix</span>: /
    <span style=color:#ff79c6>rewrite</span>:
      <span style=color:#ff79c6>uri</span>: /
    <span style=color:#ff79c6>route</span>:
    - <span style=color:#ff79c6>destination</span>:
        <span style=color:#ff79c6>host</span>: centraldashboard.kubeflow.svc.cluster.local
        <span style=color:#ff79c6>port</span>:
          <span style=color:#ff79c6>number</span>: <span style=color:#bd93f9>80</span>
</code></pre></div><p>To install the basic components of Kubeflow, clone the repository and from the root directory run:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k kubeflow
</code></pre></div><p>Once all pods in the Kubeflow namespace are up and running, navigate to <a href=https://INGRESS_HOST><code>https://$INGRESS_HOST</code></a>. The <code>Gateway</code> should redirect the browser to the Dex login page and, after the login is successful, to the Central Dashboard page. Below, is a quick demo:</p>
<p>
<img src=/blog/2021-12-16/kubeflow-auth-demo.gif alt="Kubeflow Authentication Demo">
</p>
<p>This demonstrates that the external authorization policy works as expected, required headers are set by the authentication workflow, <code>AuthorizationPolicies</code> are applied correctly, and the configuration of Kubeflow components is compatible with the provided authorization stack.</p>
<h2 id=conclusion>Conclusion</h2>
<p>Setting up the secure ingress with authentication requires an understanding of all the moving parts
and interactions between them to address this task properly. Treating the authentication stack
independently from the applications that depend on it looks preferable from the cluster management
perspective when multiple applications benefit from the centralized solution.</p>
<p>The manual installation is pretty involving and error-prone. As there are several systems with non-trivial configuration involved, these steps are great candidates for being automated and installed as
self-contained units of the infrastructure with solutions such as Flux or ArgoCD.</p>
<hr>
<h2 id=references>References</h2>
<ol>
<li>Istio documentation on <a href=https://istio.io/latest/docs/concepts/traffic-management/>Traffic Management</a></li>
<li><a href=https://istio.io/latest/blog/2021/better-external-authz/>Better External Authorization</a> blog post from Istio</li>
<li>Istio documentation on best practices for <a href=https://istio.io/latest/docs/setup/additional-setup/gateway/>Installing Gateways</a></li>
<li><a href=https://www.jetstack.io/blog/istio-oidc/>Istio OIDC Authentication</a> blog post from JetStack</li>
<li><a href=https://homelab.blog/blog/devops/Istio-OIDC-Config/>Configuring Istio with OIDC authentication</a> blog post by Justin Gauthier</li>
</ol>
<nav class=pagination role=navigation>
<a class=newer-posts href=/kubernetes-homelab-with-proxmox-kubeadm-calico-openebs-and-metallb/>&larr; Previous Post</a>
</nav>
</div>
<div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container">
<div class=side-catalog>
<hr class="hidden-sm hidden-xs">
<h5>
<a class=catalog-toggle href=#>CONTENTS</a>
</h5>
<ul class=catalog-body></ul>
</div>
</div>
<div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container">
<section>
<hr class="hidden-sm hidden-xs">
<h5><a href=/tags/>FEATURED TAGS</a></h5>
<div class=tags>
<a href=/tags/akka title=akka>
akka
</a>
<a href=/tags/cassandra title=cassandra>
cassandra
</a>
<a href=/tags/istio title=istio>
istio
</a>
<a href=/tags/kubeflow title=kubeflow>
kubeflow
</a>
<a href=/tags/kubernetes title=kubernetes>
kubernetes
</a>
<a href=/tags/mesos title=mesos>
mesos
</a>
<a href=/tags/sheduling title=sheduling>
sheduling
</a>
<a href=/tags/spark title=spark>
spark
</a>
</div>
</section>
</div>
</div>
</div>
</article>
<footer class="site-footer clearfix">
<section class=copyright><a href>datastrophic</a> &copy; 2021</section>
<section class=poweredby>Proudly generated by <a class=icon-hugo href=http://gohugo.io>HUGO</a></section>
</footer>
<script>function loadAsync(f,b){var c=document,d='script',a=c.createElement(d),e=c.getElementsByTagName(d)[0];a.src=f,b&&a.addEventListener('load',function(a){b(null,a)},!1),e.parentNode.insertBefore(a,e)}</script>
<script>$('#tag_cloud').length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:'#bbbbee',end:'#0085a1'}},$('#tag_cloud a').tagcloud()})</script>
<script>loadAsync("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js",function(){var a=document.querySelector("nav");a&&FastClick.attach(a)})</script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-65032691-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript>function generateCatalog(a){_containerSelector='div.post-container';var h=$(_containerSelector),c,d,e,f,g,b;return c=h.find('h1,h2,h3,h4,h5,h6'),$(a).html(''),c.each(function(){d=$(this).prop('tagName').toLowerCase(),g="#"+$(this).prop('id'),e=$(this).text(),b=$('<a href="'+g+'" rel="nofollow">'+e+'</a>'),f=$('<li class="'+d+'_nav"></li>').append(b),$(a).append(f)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(a){a.preventDefault(),$('.side-catalog').toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$('.catalog-body').onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script>
</body>
</html>